import pandas as pd


# Run STARsolo_sort, index_bams and filter_GeneFull_STARsolo
def targets_STARsolo(conf_f) -> list:

    inp_pref = conf_f['STARsolo_pipeline']['bams_dir']
    bai_suff = conf_f['STARsolo_pipeline']['bai']
    gf_mat = conf_f['STARsolo_pipeline']['genefull_matrix']
    gf_features = conf_f['STARsolo_pipeline']['genefull_features']
    barcodes_stats = conf_f['STARsolo_pipeline']['barcodes_stats']
    f_st = conf_f['fold_struct']

    target_list = [f"{inp_pref}{f_st}{bai_suff}", f"{inp_pref}{f_st}{gf_mat}", 
        f"{inp_pref}{f_st}{gf_features}", f"{inp_pref}{f_st}{barcodes_stats}"]
    return target_list



def targets_PICARD(conf_f, progs='all') -> list:
    
    inp_pref = conf_f['STARsolo_pipeline']['bams_dir']
    rna_seq_suff = conf_f['picard_pipeline']['rnaseq_metrics']
    gc_met_suff = conf_f['picard_pipeline']['gc_bias_metrics']
    gc_summ_suff = conf_f['picard_pipeline']['gc_summary_metrics']
    f_st=conf_f['fold_struct']

    files_dict = {'RNAseq':rna_seq_suff, 'GC':[gc_met_suff, gc_summ_suff]}
    target_list = []
    if progs == 'all':
       # Run both PICARD programs
        for k, val in files_dict.items():
            if isinstance(val, list):
                for l_val in val:
                    target_list.append(f"{inp_pref}{f_st}{l_val}")

            else:
                target_list.append(f"{inp_pref}{f_st}{val}")

    elif progs == "RNAseq":
        # Only RNAseq metrics
        target_list.extend( [f"{inp_pref}{f_st}{val}"  for val in files_dict[progs]] )

    elif progs == "GC":
        # Only GC bias metrics
        target_list.extend( [f"{inp_pref}{f_st}{val}"  for val in files_dict[progs]] )
    else:
        # print("Wrong input; Check for editing errors!")
        return []

    return target_list



# Temporary function, will change to targets_gt_demux
def targets_cellSNP(conf_f) -> list:
    out_dir = conf_f['gt_demux_pipeline']['cellsnp_dir']
    fs_gt = conf_f['fold_struct_gt_demux']
    cells_suff = conf_f['gt_demux_pipeline']['cellsnp_cells']
    base_suff = conf_f['gt_demux_pipeline']['cellsnp_base']

    target_list = [f"{out_dir}{fs_gt}{cells_suff}", f"{out_dir}{fs_gt}{base_suff}"]
    return target_list



def targets_gt_demux(conf_f) -> list:
    out_dir = conf_f['gt_demux_pipeline']['vireosnp_dir']
    fs_gt = conf_f['fold_struct_gt_demux']
    suff = config['gt_demux_pipeline']['donors_classification']
    
    return [f"{out_dir}{fs_gt}{suff}"]


# For multi-vcf_inputs
def targets_gt_demux2(conf_f) -> list:
    out_dir = conf_f['gt_demux_pipeline']['final_count_matrix_dir']
    fs_gt = conf_f['fold_struct_demux']
    
    return [f"{out_dir}{fs_gt}" ]


def targets_SplitBams(conf_f) -> list:
    out_dir = conf_f['split_bams_pipeline_gt_demux']['split_bams_proxy_dir2']
    op = conf_f['fold_struct_bam_split1']
    
    return [f"{out_dir}{op}" ]


def targets_resolve_swaps_gt_demux(conf_f) -> list:
    out_dir = conf_f['finalize_demux']['out_dir']
    fs = conf_f['fold_struct_gt_demux_redo']
    dons_file = conf_f['finalize_demux']['donor_info_swap_file']
    suff = conf_f['gt_demux_pipeline']['donors_classification']
    
    return [f"{out_dir}{fs}{suff}"]


def targets_gt_demux_identify_swaps(conf_f) -> list:
    out_dir = conf_f['identify_swaps']['mbv_out_dir']
    fs = conf_f['fold_struct_swaps_check']
    suff = conf_f['identify_swaps']['mbv_suffix']
    
    return [f"{out_dir}{fs}{suff}"]


# To run STARsolo* + kb pipeline + (optional)PICARD progs
def targets_all(conf_f, PICARD=True, progs='all') -> list:

    demuxed_mat_dir = conf_f['demux_pipeline']['final_count_matrix_dir']
    demuxed_info_dir = conf_f['demux_pipeline']['demultiplex_info_dir']    
    demux_mat_suff = conf_f['demux_pipeline']['final_count_matrix_h5ad']
    demux_info_suff = conf_f['demux_pipeline']['demultiplex_info']
    f_st_bam = conf_f['fold_struct']
    f_st = conf_f['fold_struct_demux']

    # STARsolo* + PICARD (any) progs
    if PICARD and (progs == 'all' or progs == 'RNAseq' or progs == 'GC'):
        target_list = targets_PICARD(conf_f=conf_f, progs=progs)

    else: # For any wrong values to progs or progs == None or just PICARD == False or everything else, run STARsolo*
        target_list = targets_STARsolo(conf_f=conf_f)


    # kb pipeline
    target_list.extend( [f"{demuxed_mat_dir}{f_st}{demux_mat_suff}", f"{demuxed_info_dir}{f_st}{demux_info_suff}"] )
    
    return target_list



# Add wildcards info here in the 'expand' function
def produce_targets(conf_f: pd.DataFrame, last_step: str, wc_d: dict) -> list:
    # conf_f['last_step'] is expected to be None if yaml file is provided for the config['select_fastqs']
    if last_step is not None:
        target_step = last_step.lower()
        # folder_st_bam = fs['fold_struct']
        # folder_st = fs['fold_struct_demux']

        # 'all' is only for the modules: STARsolo, PICARD (both) and calico_solo demux
        if target_step == "all":
            target_files = targets_all(conf_f=conf_f, PICARD=True, progs=target_step)
            ONLY_SOLO = True
            final_target_list = [expand(f"{target}", zip, **wc_d) for target in target_files] # if multiple wildcards are present then either 'zip' or 'product' (default)

        elif target_step == "starsolo_kb_solo":
            target_files = targets_all(conf_f=conf_f, PICARD=False, progs=None)
            ONLY_SOLO = True
            final_target_list= [expand(f"{target}", zip, **wc_d) for target in target_files]

        elif target_step == "starsolo":
            target_files = targets_STARsolo(conf_f=conf_f)

            final_target_list= [expand(f"{target}", zip, **wc_d) for target in target_files]
            
        elif target_step == "starsolo_picard":
            target_files = targets_PICARD(conf_f=conf_f, progs='all')

            final_target_list= [expand(f"{target}", zip, **wc_d) for target in target_files]

        elif target_step == "starsolo_rnaseqmet":
            target_files = targets_PICARD(conf_f=conf_f, progs='RNAseq')

            final_target_list= [expand(f"{target}", zip, **wc_d) for target in target_files]

        elif target_step == "starsolo_gcbiasmet":
            target_files = targets_PICARD(conf_f=conf_f, progs='GC')

            final_target_list= [expand(f"{target}", zip, **wc_d) for target in target_files]

        elif target_step == "starsolo_cellsnp":
            target_files = targets_cellSNP(conf_f=conf_f)

            final_target_list= [expand(f"{target}", zip, **wc_d) for target in target_files]    

        elif target_step == "starsolo_split_bams":
            target_files = targets_SplitBams(conf_f=conf_f)

            final_target_list= [expand(f"{target}", zip, **wc_d) for target in target_files]

        elif target_step == "starsolo_split_bams_gt_demux":
            target_files = targets_SplitBams(conf_f=conf_f)
            suff = ".txt"
            # temp_list= [expand(f"{target}", zip, num=round_num, **wc_d) for target in target_files][0] # Multiple wildcards example
            final_target_list= [expand(f"{target}{suff}", zip, **wc_d) for target in target_files][0] # Single wildcard
            # final_target_list.append(f"{config['split_bams_pipeline_gt_demux']['ngscheckmate_res_dir']}/{config['split_bams_pipeline_gt_demux']['proj_name']}_all.txt")

        # Multi_vcf inputs or when a subdir with the vcf name is needed
        elif target_step == "starsolo_split_bams_gt_demux_multi_vcf":
            # Add final steps for split_bams
            target_files = targets_SplitBams(conf_f=conf_f)
            suff = ".txt"
            # If multiple vcfs per sample needs to be run or not
            if isinstance(VCF_TYPE, list):
                
                temp_list = [expand(f"{target}", zip, **wc_d) for target in target_files][0] # Multiple wildcards example
                # temp_list= [expand(f"{target}", **wc_d) for target in target_files][0] # Single wildcard
                final_target_list = [expand(f"{t}_{{vcf_type}}{suff}", vcf_type=VCF_TYPE) for t in temp_list]

            # Single vcf out of a set of multiple vcfs
            elif isinstance(VCF_TYPE, str):
                
                final_target_list = [expand(f"{target}_{VCF_TYPE}{suff}", zip, **wc_d) for target in target_files] # Multiple wildcards example
                # final_target_list= [expand(f"{target}_{VCF_TYPE}{suff}", **wc_d) for target in target_files] # Single wildcard
            else:
                raise ValueError("The wildcard used to test multi_vcf input (VCF_TYPE) is of unexpected type! Please check")

            # Add final steps for gt_demux
            target_files = targets_gt_demux2(conf_f=conf_f)
            suff = config['gt_demux_pipeline']['final_count_matrix_h5ad']
            # ONLY_VIREO = True # Set this or ADD_VIREO by figuring out or asking user input

            # If multiple vcfs per sample needs to be run
            if isinstance(VCF_TYPE, list):
                
                temp_list = [expand(f"{target}", zip, **wc_d) for target in target_files][0] # Multiple wildcards example
                # temp_list= [expand(f"{target}", **wc_d) for target in target_files][0] # Single wildcard
                final_target_list2 = [expand(f"{t}_{{vcf_type}}{suff}", vcf_type=VCF_TYPE) for t in temp_list]

            # Single vcf out of a set of multiple vcfs
            elif isinstance(VCF_TYPE, str):
                
                final_target_list2 = [expand(f"{target}_{VCF_TYPE}{suff}", zip, **wc_d) for target in target_files] # Multiple wildcards example
                # final_target_list= [expand(f"{target}_{VCF_TYPE}{suff}", **wc_d) for target in target_files] # Single wildcard
            else:
                raise ValueError("The wildcard used to test multi_vcf input (VCF_TYPE) is of unexpected type! Please check")

            final_target_list.extend(final_target_list2)
            # final_target_list.append(f"{config['split_bams_pipeline_gt_demux']['ngscheckmate_res_dir']}/{config['split_bams_pipeline_gt_demux']['proj_name']}_all.txt")

        elif target_step == "starsolo_rnaseqmet_kb_solo":
            target_files = targets_all(conf_f=conf_f, progs='RNAseq')
            ONLY_SOLO = True
            final_target_list= [expand(f"{target}", zip, **wc_d) for target in target_files]

        elif target_step == "starsolo_gcbiasmet_kb_solo":
            target_files = targets_all(conf_f=conf_f, progs='GC')
            ONLY_SOLO = True
            final_target_list= [expand(f"{target}", zip, **wc_d) for target in target_files]

            
        elif target_step == "starsolo_gt_demux":
            target_files = targets_gt_demux(conf_f=conf_f)
            ONLY_VIREO = True
            final_target_list= [expand(f"{target}", zip, **wc_d) for target in target_files]

        # Multi_vcf inputs or when a subdir with the vcf name is needed
        elif target_step == "starsolo_gt_demux_multi_vcf":
            target_files = targets_gt_demux2(conf_f=conf_f)
            suff = config['gt_demux_pipeline']['final_count_matrix_h5ad']
            # ONLY_VIREO = True # Set this or ADD_VIREO by figuring out or asking user input

            # If multiple vcfs per sample needs to be run
            if isinstance(VCF_TYPE, list):
                
                temp_list= [expand(f"{target}", zip, **wc_d) for target in target_files][0] # Multiple wildcards example
                # temp_list= [expand(f"{target}", **wc_d) for target in target_files][0] # Single wildcard
                final_target_list=[expand(f"{t}_{{vcf_type}}{suff}", vcf_type=VCF_TYPE) for t in temp_list]

            # Single vcf out of a set of multiple vcfs
            elif isinstance(VCF_TYPE, str):
                
                final_target_list= [expand(f"{target}_{VCF_TYPE}{suff}", zip, **wc_d) for target in target_files] # Multiple wildcards example
                # final_target_list= [expand(f"{target}_{VCF_TYPE}{suff}", **wc_d) for target in target_files] # Single wildcard
            else:
                raise ValueError("The wildcard used to test multi_vcf input (VCF_TYPE) is of unexpected type! Please check")

        elif target_step == "starsolo_gt_demux_identify_swaps":
            target_files = targets_gt_demux_identify_swaps(conf_f=conf_f)
            final_target_list= [expand(f"{target}", zip, **wc_d) for target in target_files]

        elif target_step == "starsolo_resolve_swaps_gt_demux":
            target_files = targets_resolve_swaps_gt_demux(conf_f=conf_f)
            final_target_list= [expand(f"{target}", zip, **wc_d) for target in target_files]

        else:
            # print("Wrong inputs to produce_targets function!!")
            return []


        # Fail-safe return statement
        return final_target_list


    else:
        raise ValueError("The variable last_step is set to None!")



