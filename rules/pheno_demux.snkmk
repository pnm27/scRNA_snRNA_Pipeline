def read_files_ext(fname) -> pd.DataFrame :
    if not os.path.isfile(fname):
        raise OSError(f"The given file {fname} doesn't exist and annotations are impossible without this file!") 
    if fname.endswith('.csv'):
        return pd.read_csv(fname)
    elif fname.endswith('.tsv'):
        return pd.read_csv(fname, sep='\t')
    else:
        raise OSError(f"The given file {fname} doen't have either csv or tsv extension. Other extensions are not supported!")


def get_donors(wildcards, input):
    # temp_df = pd.read_csv(config['meta_data_geno_samp'], skiprows=1, names=config['hash_columns'])
    # donors = ','.join(temp_df.loc[temp_df[config['hash_columns'][2]] == wildcards.id1[:-6], config['hash_columns'][1]].to_list())
    # Dictionary containing keys 'donor' - number of donors and 'vcf' - a vcf file or a list of vcf files using which we want to run
    vals=dict.fromkeys(['donor', 'vcf'])
    temp_df = read_files_ext(config['phe_demux_pipeline']['vcf_info'])
    wet_lab_df = read_files_ext(config['wet_lab_info'])
    samp=wildcards.id1.replace('-', '_')+'_cDNA'
    cols1=config['phe_demux_pipeline']['vcf_info_columns']
    cols2=config['phe_demux_pipeline']['wet_lab_file_cols']
    set_num=wet_lab_df.loc[wet_lab_df[cols2[1]] == samp, cols2[0]].values[0]
    vals['donor'] = temp_df.loc[temp_df[cols1[0]] == set_num, cols1[1]].values[0]
    vals['vcf'] = temp_df.loc[temp_df[cols1[0]] == set_num, cols1[2:]].squeeze().tolist()

    return vals



rule create_inp_cellSNP:
    input:
        f"{config['demux_pipeline']['final_count_matrix_dir']}{config['fold_struct_demux']}{config['demux_pipeline']['final_count_matrix_h5ad']}"

    priority: 8

    params:
        col_name=config['phe_demux_pipeline']['demux_col'], # Name of the anndata's obs column that contains classification of cells
        bc_len=config['phe_demux_pipeline']['barcode_len'], # Barcode length
        doub=config['phe_demux_pipeline']['doublet'], # Doublets classified as
        neg=config['phe_demux_pipeline']['negative'], # Negatives classified as
        na=config['phe_demux_pipeline']['na'] # Cells not present in hashsolo classified as

    resources:
        mem_mb=allocate_mem_CICS,
        time_min=allocate_time_CICS

    # group: "phenotype-demux"

    output:
        f"{config['phe_demux_pipeline']['inp_for_cellsnp_dir']}{config['fold_struct_filt_bc']}.txt"

    shell:
        """
        python3 helper_py_scripts/create_inp_cellSNP.py {input} -o {output} -c "{params.col_name}" -e "{params.na}" -d "{params.doub}" -n "{params.neg}" -b {params.bc_len}
        sleep 100
        """


# Not yet finished implementing
rule get_id_hash:
    input:


    output:
        config['phe_demux_pipeline']['meta_data_geno_samp']

    shell:
        """
        sleep 100
        """


# UMI tag is turned on. Therefore, PCR duplicates are included
rule cellSNP:
    input:
        # bc=get_filt_barcodes,
        bc=f"{config['phe_demux_pipeline']['inp_for_cellsnp_dir']}{config['fold_struct_filt_bc']}.txt",
        bams=f"{config['STARsolo_pipeline']['bams_dir']}{config['fold_struct']}{config['STARsolo_pipeline']['bam']}"

    # group: "phenotype-demux"

    output:
        f"{config['phe_demux_pipeline']['cellsnp_dir']}{config['fold_struct_phe_demux']}{config['phe_demux_pipeline']['cellsnp_cells']}",
        f"{config['phe_demux_pipeline']['cellsnp_dir']}{config['fold_struct_phe_demux']}{config['phe_demux_pipeline']['cellsnp_base']}"

    params:
        ref_snps=config['phe_demux_pipeline']['ref_snps'],
        umi_tag=config['phe_demux_pipeline']['umi_tag'],
        cell_tag=config['phe_demux_pipeline']['cell_tag'],
        processors=config['phe_demux_pipeline']['n_proc'],
        min_maf=config['phe_demux_pipeline']['min_maf'],
        min_ct=config['phe_demux_pipeline']['min_aggr_count'],
        output_prefix=lambda wildcards, output: output[0].replace(f"/{config['phe_demux_pipeline']['cellsnp_cells']}", '')

    threads: 8

    resources:
        mem_mb=allocate_mem_cS,
        time_min=allocate_time_cS

    shell: "cellsnp-lite -s {input.bams} -b {input.bc} -O {params.output_prefix} -R {params.ref_snps} -p {params.processors} --minMAF {params.min_maf} --minCOUNT {params.min_ct} --cellTAG {params.cell_tag} --UMItag {params.umi_tag} --genotype --gzip"


# If one wants to split a compiled vcf into per-pool vcf
# if config['phe_demux_pipeline']['split_compiled_vcf']:
#     rule split_compiled_vcf:
#         input:

#         output:

#         shell:
#             """

#             """



rule vireoSNP:
    input:
        f"{config['phe_demux_pipeline']['cellsnp_dir']}{config['fold_struct_phe_demux']}{config['phe_demux_pipeline']['cellsnp_cells']}"
  
    output:
        f"{config['phe_demux_pipeline']['vireosnp_dir']}{config['fold_struct_phe_demux']}{config['phe_demux_pipeline']['donors_vcf']}"
        #f"{config['filt_vcf_dir']}{config['fold_struct_kb']}{config['filt_vcf']}"


    # group: "phenotype-demux"

    params:
        donor_info=get_donors,
        geno_tag=config['phe_demux_pipeline']['donor_genotype'],
        output_prefix=lambda wildcards, output: output[0].replace(f"/{config['phe_demux_pipeline']['donors_vcf']}", '')

    threads: 7

    resources:
        mem_mb=allocate_mem_vS,
        time_min=allocate_time_vS
        
    shell:
        """
        ml bcftools
        for f in `echo "{params.donor_info[vcf]}" | tr ' ' '\n'`
        do
            echo "Executing vireoSNP using the vcf file ${{f}}"
            vireo -c {input} -d ${{f}} -N {params.donor_info[donor]} -o {params.output_prefix} -t {params.geno_tag} --noPlot
            echo
            sleep 20
        done
        sleep 50
        """

