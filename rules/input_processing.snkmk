import yaml
from snakemake.utils import validate


# Limitting Step for the run of Snakemake, creating wildcards
# If the input is a text file containing the folder structure to the fastqs
if os.path.isfile(config['select_fastqs']) and not config['select_fastqs'].endswith('.yaml') and not config['select_fastqs'].endswith('.yml'):
    #Lists that will contain wildcards

    # Value of last_step should be regulated by the json schema
    assert isinstance(conf_f['last_step'], str), "'select_fastqs' in new_config.yaml is not a yaml file. Hence, value in last_step should be one of the modules!"


    round_num=[] # wildcard 'num'
    sample_name=[] # wildcard 'id1'
    with open(config['select_fastqs']) as fq:
        for line in fq:
            line_sp = line.split('/')
            round_num.append(line_sp[0])
            sample_name.append(line_sp[2].strip().replace('-cDNA', ''))

# If the input is yaml file then validate it and process it
elif os.path.isfile(config['select_fastqs']) and config['select_fastqs'].endswith('.yaml') or config['select_fastqs'].endswith('.yml'):
    # validate(config, "config.schema.json")

    # Value of last_step should be regulated by the json schema
    if not isinstance(conf_f['last_step'], str) or not (config['last_step'].endswith('.yaml') or config['last_step'].endswith('.yml')):
        raise ValueError("Value in last_step should be one of the modules or a yaml file containing acceptable module names!")

    # File exists or not
    # if not os.path.isfile(config['select_fastqs']):
    #     raise OSError("The provided file doesn't exists! Check the path.")

    # Parse the samples containing yaml file
    with open(config['select_fastqs']) as fout:
        sample_dict = yaml.load(fout, Loader=yaml.SafeLoader)

    sample_set_names = [] # contains the keys that categorizes multiple modules (same names should be present in the modules_yaml file)
    files_list=[] # List of list
    wildcards_list=[] # List of list
    modules_list=[] # List of list

    # Check if the yaml file has list of inputs or regex patterns
    for k, v in sample_dict.keys():
        sample_set_names.append(k)
        files_list.append(v)

    # How to parse the values of wildcards


    


# If the input is a dir containing all the fastqs
elif os.path.isdir(config['select_fastqs']):
    pass

else:
    raise ValueError("Unrecognized input file! Can't go ahead with the pipeline!")


# Create a dict of wildcards
wc_d={'id1':sample_name, 'num':round_num}

# For multiruns of cellSNP and vireoSNP
# VCF_TYPE=config['phe_demux_pipeline']['vcf_info_columns'][2:]