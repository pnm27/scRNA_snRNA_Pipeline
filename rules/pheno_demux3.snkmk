# This rule will create multiple runs of cellSNP and vireoSNP for each sample
# Provided a file that contains multiple vcfs per each sample
# present as config['phe_demux_pipeline']['vcf_info']

def read_files_ext(fname) -> pd.DataFrame :
    if not os.path.isfile(fname):
        raise OSError(f"The given file {fname} doesn't exist and annotations are impossible without this file!") 
    if fname.endswith('.csv'):
        return pd.read_csv(fname)
    elif fname.endswith('.tsv'):
        return pd.read_csv(fname, sep='\t')
    else:
        raise OSError(f"The given file {fname} doen't have either csv or tsv extension. Other extensions are not supported!")


def get_donors(wildcards, input):
    # temp_df = pd.read_csv(config['meta_data_geno_samp'], skiprows=1, names=config['hash_columns'])
    # donors = ','.join(temp_df.loc[temp_df[config['hash_columns'][2]] == wildcards.id1[:-6], config['hash_columns'][1]].to_list())
    # Dictionary containing keys 'donor' - number of donors and 'vcf' - a vcf file or a list of vcf files using which we want to run
    vals=dict.fromkeys(['donor', 'vcf'])
    temp_df = read_files_ext(config['phe_demux_pipeline']['vcf_info'])
    wet_lab_df = read_files_ext(config['wet_lab_info'])
    samp=wildcards.id1.replace('-', '_')+'_cDNA'
    cols1=config['phe_demux_pipeline']['vcf_info_columns']
    cols2=config['phe_demux_pipeline']['wet_lab_file_cols']
    set_num=wet_lab_df.loc[wet_lab_df[cols2[1]].str.lower() == samp.lower(), cols2[0]].values[0]
    vals['donor'] = temp_df.loc[temp_df[cols1[0]] == set_num, cols1[1]].values[0]
    vals['vcf'] = temp_df.loc[temp_df[cols1[0]] == set_num, wildcards.vcf_type].values[0]

    return vals


def multi_vcfs(wildcards):
    temp_df = read_files_ext(config['phe_demux_pipeline']['vcf_info'])
    wet_lab_df = read_files_ext(config['wet_lab_info'])
    samp=wildcards.id1.replace('-', '_')+'_cDNA'
    cols1=config['phe_demux_pipeline']['vcf_info_columns']
    cols2=config['phe_demux_pipeline']['wet_lab_file_cols']
    set_num=wet_lab_df.loc[wet_lab_df[cols2[1]].str.lower() == samp.lower(), cols2[0]].values[0]
    col=wildcards.vcf_type

    return temp_df.loc[temp_df[cols1[0]] == set_num, col].values[0]


rule create_inp_cellSNP:
    input:
        f"{config['demux_pipeline']['final_count_matrix_dir']}{config['fold_struct_demux']}{config['demux_pipeline']['final_count_matrix_h5ad']}"

    priority: 8

    params:
        col_name=config['phe_demux_pipeline']['demux_col'], # Name of the anndata's obs column that contains classification of cells
        bc_len=config['phe_demux_pipeline']['barcode_len'], # Barcode length
        keep_all_cells=config['phe_demux_pipeline']['include_all_cells'],
        doub=config['phe_demux_pipeline']['doublet'], # Doublets classified as
        neg=config['phe_demux_pipeline']['negative'], # Negatives classified as
        na=config['phe_demux_pipeline']['na'] # Cells not present in hashsolo classified as

    resources:
        mem_mb=allocate_mem_CICS,
        time_min=allocate_time_CICS

    # group: "phenotype-demux"

    output:
        f"{config['phe_demux_pipeline']['inp_for_cellsnp_dir']}{config['fold_struct_filt_bc']}.txt"

    shell:
        """
        if [[ "{params.keep_all_cells}" == "yes" ]] || [[ "{params.keep_all_cells}" == "True" ]]; then
            python3 helper_py_scripts/create_inp_cellSNP.py {input} -o {output} -c {params.col_name} -b {params.bc_len} --keep_all_cells
        else
            python3 helper_py_scripts/create_inp_cellSNP.py {input} -o {output} -c {params.col_name} -e {params.na} -d {params.doub} -n {params.neg} -b {params.bc_len}
        fi
        sleep 100
        """


# Not yet finished implementing
rule get_id_hash:
    input:


    output:
        config['phe_demux_pipeline']['meta_data_geno_samp']

    shell:
        """
        sleep 100
        """


# UMI tag is turned on. Therefore, PCR duplicates are included
rule cellSNP:
    input:
        # bc=get_filt_barcodes,
        bc=f"{config['phe_demux_pipeline']['inp_for_cellsnp_dir']}{config['fold_struct_filt_bc']}.txt",
        bams=f"{config['STARsolo_pipeline']['bams_dir']}{config['fold_struct']}{config['STARsolo_pipeline']['bam']}",
        ref_snps=multi_vcfs,
        genome_1k_ref=config['phe_demux_pipeline']['genome_1k_ref']

    # group: "phenotype-demux"

    output:
        f"{config['phe_demux_pipeline']['cellsnp_dir']}{config['fold_struct_phe_demux']}/{config['phe_demux_pipeline']['cellsnp_cells']}",
        f"{config['phe_demux_pipeline']['cellsnp_dir']}{config['fold_struct_phe_demux']}/{config['phe_demux_pipeline']['cellsnp_base']}"

    params:
        # ref_snps=config['phe_demux_pipeline']['ref_snps'],
        umi_tag=config['phe_demux_pipeline']['umi_tag'],
        cell_tag=config['phe_demux_pipeline']['cell_tag'],
        processors=config['phe_demux_pipeline']['n_proc'],
        min_maf=config['phe_demux_pipeline']['min_maf'],
        min_ct=config['phe_demux_pipeline']['min_aggr_count'],
        output_prefix=lambda wildcards, output: output[0].replace(f"/{config['phe_demux_pipeline']['cellsnp_cells']}", ''),
        filt_vcf_dir=f"{config['phe_demux_pipeline']['filt_vcf_dir']}{config['fold_struct_phe_demux']}",
        threads=config['phe_demux_pipeline']['bcftools_thread']

    threads: 1

    resources:
        mem_mb=allocate_mem_cS,
        time_min=allocate_time_cS

    shell:
        """
        ml bcftools/1.15.1
        bcftools isec --threads {params.threads} -e- -i'INFO/AF>0.25' -Oz -p {params.filt_vcf_dir} {input.ref_snps} {input.genome_1k_ref}
        cellsnp-lite -s {input.bams} -b {input.bc} -O {params.output_prefix} -R {params.filt_vcf_dir}"/0002.vcf.gz" -p {params.processors} --minMAF {params.min_maf} --minCOUNT {params.min_ct} --cellTAG {params.cell_tag} --UMItag {params.umi_tag} --genotype --gzip
        """
        



# rule filter_cellSNP:
#     input:
#         f"{config['phe_demux_pipeline']['cellsnp_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['cellsnp_cells']}",
#         f"{config['phe_demux_pipeline']['cellsnp_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['cellsnp_base']}",
#         bed_file=config['phe_demux_pipeline']['top_genes_cs_filt_bed']

#     output:
#         temp(f"{config['phe_demux_pipeline']['temp_cellsnp_filt_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['cellsnp_cells']}"),
#         f"{config['phe_demux_pipeline']['temp_cellsnp_filt_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['cellsnp_base']}"

#     params:
#         threads=config['phe_demux_pipeline']['bcftools_thread'],
#         temp_vcf_gz_file=f"{config['phe_demux_pipeline']['temp_cellsnp_filt_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['temp_cellsnp_base']}",
#         temp_vcf_file=f"{config['phe_demux_pipeline']['temp_cellsnp_filt_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['temp_cellsnp_base']}".replace('.gz', ''),
#         temp_vcf_gz_file2=f"{config['phe_demux_pipeline']['temp_cellsnp_filt_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['temp2_cellsnp_base']}"

#     threads: 1

#     resources:
#         mem_mb=allocate_mem_FCS,
#         time_min=allocate_time_FCS

#     shell:
#         """
#         ml bcftools
#         if [ ! -f "{input[0]}.csi" ]; then bcftools index {input[0]}; fi
#         bcftools view --threads {params.threads} -Oz -o {output[0]} -R {input.bed_file} {input[0]}
#         zcat {input[0]} | grep "^#" | grep -E "fileformat|INFO.*AD|INFO.*DP|INFO.*OTH|contig" | cat - <(zcat {input[1]} | tail -n +2) > {params.temp_vcf_file}
#         bcftools view -Oz -o {params.temp_vcf_gz_file} {params.temp_vcf_file}
#         bcftools index {params.temp_vcf_gz_file}
#         bcftools view --threads {params.threads} -Oz -o {params.temp_vcf_gz_file2} {params.temp_vcf_gz_file}
#         zcat {params.temp_vcf_gz_file2} | sed "2,33d" | gzip > {output[1]}
#         rm {params.temp_vcf_gz_file2} {params.temp_vcf_gz_file} {params.temp_vcf_file}
#         """


# rule filter_cellSNP:
#     input:
#         f"{config['phe_demux_pipeline']['cellsnp_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['cellsnp_cells']}",
#         f"{config['phe_demux_pipeline']['cellsnp_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['cellsnp_base']}"

#     output:
#         temp(f"{config['phe_demux_pipeline']['temp_cellsnp_filt_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['cellsnp_cells']}"),
#         f"{config['phe_demux_pipeline']['temp_cellsnp_filt_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['cellsnp_base']}"

#     params:
#         threads=config['phe_demux_pipeline']['bcftools_thread'],
#         temp_vcf_gz_file=f"{config['phe_demux_pipeline']['temp_cellsnp_filt_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['temp_cellsnp_base']}",
#         temp_vcf_file=f"{config['phe_demux_pipeline']['temp_cellsnp_filt_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['temp_cellsnp_base']}".replace('.gz', ''),
#         temp_vcf_gz_file2=f"{config['phe_demux_pipeline']['temp_cellsnp_filt_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['temp2_cellsnp_base']}"

#     threads: 1

#     resources:
#         mem_mb=allocate_mem_FCS,
#         time_min=allocate_time_FCS

#     shell:
#         """
#         ml bcftools
#         if [ ! -f "{input[0]}.csi" ]; then bcftools index {input[0]}; fi
#         bcftools view --threads {params.threads} -Oz -o {output[0]} -R {input.bed_file} {input[0]}
#         zcat {input[0]} | grep "^#" | grep -E "fileformat|INFO.*AD|INFO.*DP|INFO.*OTH|contig" | cat - <(zcat {input[1]} | tail -n +2) > {params.temp_vcf_file}
#         bcftools view -Oz -o {params.temp_vcf_gz_file} {params.temp_vcf_file}
#         bcftools index {params.temp_vcf_gz_file}
#         bcftools view --threads {params.threads} -Oz -o {params.temp_vcf_gz_file2} {params.temp_vcf_gz_file}
#         zcat {params.temp_vcf_gz_file2} | sed "2,33d" | gzip > {output[1]}
#         rm {params.temp_vcf_gz_file2} {params.temp_vcf_gz_file} {params.temp_vcf_file}
#         """







rule vireoSNP:
    input:
        f"{config['phe_demux_pipeline']['cellsnp_dir']}{config['fold_struct_phe_demux']}/{config['phe_demux_pipeline']['cellsnp_cells']}"
        # f"{config['phe_demux_pipeline']['temp_cellsnp_filt_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['cellsnp_cells']}"
  
    output:
        # f"{config['phe_demux_pipeline']['vireosnp_dir']}{config['fold_struct_phe_demux']}{{vcf_type}}/{config['phe_demux_pipeline']['donors_vcf']}", # Subject to removal
        f"{config['phe_demux_pipeline']['vireosnp_dir']}{config['fold_struct_phe_demux']}/{config['phe_demux_pipeline']['donors_classification']}"
        #f"{config['filt_vcf_dir']}{config['fold_struct_kb']}{config['filt_vcf']}"


    # group: "phenotype-demux"

    params:
        donor_info=get_donors,
        geno_tag=config['phe_demux_pipeline']['donor_genotype'],
        output_prefix=lambda wildcards, output: output[0].replace(f"/{config['phe_demux_pipeline']['donors_vcf']}", '')

    threads: 5

    resources:
        mem_mb=allocate_mem_vS,
        time_min=allocate_time_vS
        
    shell:
        """
        if [ "{params.donor_info[donor]}" -eq "6" ]; then
            vireo -c {input} -d {params.donor_info[vcf]} -N 6 -o {params.output_prefix} -t {params.geno_tag} --noPlot --forceLearnGT
        else
            vireo -c {input} -d {params.donor_info[vcf]} -N 6 -o {params.output_prefix} -t {params.geno_tag} --noPlot
        fi
        sleep 180
        """


# Merge this as one from calico_solo
# rule demux_samples_calico_solo_STARsolo:
#     input:
#         f"{config['demux_pipeline']['calico_solo_dir']}{config['fold_struct_demux']}{config['demux_pipeline']['calico_solo_h5ad']}",
#         starsolo_out=f"{config['STARsolo_pipeline']['bams_dir']}{config['fold_struct']}{config['STARsolo_pipeline']['genefull_matrix']}"

#     # priority: 8

#     output:
#         f"{config['demux_pipeline']['final_count_matrix_dir']}{config['fold_struct_demux']}{config['demux_pipeline']['final_count_matrix_h5ad']}",
#         f"{config['demux_pipeline']['demultiplex_info_dir']}{config['fold_struct_demux']}{config['demux_pipeline']['demultiplex_info']}"

#     params:
#         mito=config['demux_pipeline']['max_mito_percentage'],  # Max mitochodrial genes content per cell
#         min_genes=config['demux_pipeline']['min_genes_per_cell'], # Min #genes per cell
#         min_cells=config['demux_pipeline']['min_cells_per_gene'],  # Min #cells expressing a gene for it to pass the filter
#         samples_info=config['wet_lab_info'], # File containing multiplexing info of each set
#         cols=config['demux_pipeline']['columns_to_pick'],  # Which columns of the wet lab info file correspond RESPECTIVELY to cDNA_ID(should correspond to the name of the processed file), HTO numbers and Donors/SubIDs (Header names and not numbers)
#         genes_info=config['demux_pipeline']['gene_info_file'], # File containing gene names and gene ids for annotations
#         sample_name="{id1}",
#         hto_sep=config['demux_pipeline']['hto_sep']

    
#     resources:
#         mem_mb=allocate_mem_DXP,
#         time_min=allocate_time_DXP

#     shell:
#         """
#         samp={params.sample_name}
#         if [[ "{params.hto_sep}" == "None" ]]; then
#             python3 helper_py_scripts/demul_samples.py {input[0]} {input[1]} {output[0]} {output[1]} {params.genes_info} {params.samples_info} -m {params.mito} -g {params.min_genes} -c {params.min_cells} --columns {params.cols} \
#         -s {params.sample_name}
#         else
#             python3 helper_py_scripts/demul_samples.py {input[0]} {input[1]} {output[0]} {output[1]} {params.genes_info} {params.samples_info} -m {params.mito} -g {params.min_genes} -c {params.min_cells} --columns {params.cols} \
#         -s {params.sample_name} --hto_sep {params.hto_sep}
#         fi
#         sleep 100
#         """


# Temporarily add this rule. Figure an elegant way to do this!
# The ideal one will be where the rule includes both at the same time or either according to the chosen modules
rule add_obs_to_final_count_matrix:
    input:
        f"{config['demux_pipeline']['final_count_matrix_dir']}{config['fold_struct_demux']}{config['demux_pipeline']['final_count_matrix_h5ad']}",
        f"{config['phe_demux_pipeline']['vireosnp_dir']}{config['fold_struct_phe_demux']}/{config['phe_demux_pipeline']['donors_classification']}",
        config['split_bams_pipeline_phe_demux']['gt_conv']

    output:
        f"{config['phe_demux_pipeline']['final_count_matrix_dir']}{config['fold_struct_phe_demux2']}{config['phe_demux_pipeline']['final_count_matrix_h5ad']}"

    resources:
        mem_mb=allocate_mem_AOTFCM,
        time_min=allocate_time_AOTFCM

    shell:
        """
        python3 helper_py_scripts/demul_samples_ext_vS.py {input[0]} {input[1]} {input[2]} {output}
        sleep 100
        """